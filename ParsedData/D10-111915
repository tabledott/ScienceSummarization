an Ndegree polynomial of the number of constants in h. The constraints were designed to increase the efficiency of the splitting algorithm without impacting performance on the development data.
    We define the set of possible splits for a category X:h with syntax X and logical form h by enumerating the solution pairs (f, g) to the higher-order unification problems defined above and creating syntactic categories for the resulting expressions.
    For example, given X :h = S\NP :Ax.in(x, tex), f = AyAx.in(x, y), and g = tex, we would produce the following two pairs of new categories: which were constructed by first choosing the syntactic category for g, in this case NP, and then enumerating the possible directions for the new slash in the category containing f. We consider each of these two steps in more detail below.
    The new syntactic category for g is determined based on its type, T(g).
    For example, T(tex) = e and T(Ax.state(x)) = (e, t).
    Then, the function QT) takes an input type T and returns 