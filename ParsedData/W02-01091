hat are a good fit for the task at hand.
    For example, a course might use Prolog for parsing, Perl for corpus processing, and a finite-state toolkit for morphological analysis.
    By relying on the built-in features of various languages, the teacher avoids having to develop a lot of software infrastructure.
    An unfortunate consequence is that a significant part of such courses must be devoted to teaching programming languages.
    Further, many interesting projects span a variety of domains, and would require that multiple languages be bridged.
    For example, a student project that involved syntactic parsing of corpus data from a morphologically rich language might involve all three of the languages mentioned above: Perl for string processing; a finite state toolkit for morphological analysis; and Prolog for parsing.
    It is clear that these considerable overheads and shortcomings warrant a fresh approach.
    Apart from the practical component, computational linguistics courses may also depend on 