fV ~ nil A rules-out((A~, V)) ~ nil then L ~ L U {(AI, V)} D ~ D - rules-out((At, V)) endlf If D = {} then if (type, X) (: L for some X then re turn  L else return L U {(type, basic-level-value(r, type))} endif endif next return failure I find-best-value(A, initial-valse) l ff user-knows(r, (A. initial-value)) = true then value ~-- initial-value else value ~ nil vndlf for v~ E taxonomy-children(initial-value) lfv~ subsumes value(r, A) A (new-value ~ find-best-value(A, vi)) ~ nil A (value = nll Y Irules-out((A, new-value)) I &gt; Irules-out((a, valse) l) then value ~ new-value endif next return value [ ,ul;s-out(&lt;A, v&gt;)[ return {x : x E D A user-knows(x, (A, V)) = false} Figure 1: The Algorithm has no discriminatory power (in which ease the basic level value is used); other attribute values are only included if, at the time they were under considera- tion, they had some discriminatory power.
  More precisely, the algorithm is as shown in Figure 1.
  Here, r is the intended referent, C is the contrast set