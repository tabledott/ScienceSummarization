/ms using 1.80 GB. cMemory use increased during scoring due to batch processing (MIT) or caching (Rand).
    The first value reports use immediately after loading while the second reports the increase during scoring. dBerkeleyLM is written in Java which requires memory be specified in advance.
    Timing is based on plentiful memory.
    Then we ran binary search to determine the least amount of memory with which it would run.
    The first value reports resident size after loading; the second is the gap between post-loading resident memory and peak virtual memory.
    The developer explained that the loading process requires extra memory that it then frees. eBased on the ratio to SRI&#8217;s speed reported in Guthrie and Hepple (2010) under different conditions.
    Memory usage is likely much lower than ours. fThe original paper (Germann et al., 2009) provided only 2s of query timing and compared with SRI when it exceeded available RAM.
    The authors provided us with a ratio between TPT and SRI under diff