 The basic idea of classical shift-reduce parsing from compiler theory (Aho and Ullman, 1972) is to perform a left-to-right scan of the input sentence, and at each step, choose one of the two actions: either shift the current word onto the stack, or reduce the top two (or more) items on the stack, replacing them with their combination.
    This idea has been applied to constituency parsing, for example in Sagae and Lavie (2006), and we describe below a simple variant for dependency parsing similar to Yamada and Matsumoto (2003) and the &#8220;arc-standard&#8221; version of Nivre (2004).
    Basically, we just need to split the reduce action into two symmetric (sub-)actions, reduceL and reduceR, depending on which one of the two Note that shift requires non-empty queue while reduce requires at least two elements on the stack. items becomes the head after reduction.
    More formally, we describe a parser configuration by a tuple (S, Q, A) where S is the stack, Q is the queue of remaining words of the input, an