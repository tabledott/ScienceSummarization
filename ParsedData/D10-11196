mation scheme that learns 0.
    Before presenting the details, we first review necessary background.
  
  
    This section provides an introduction to the ways in which we will use lambda calculus and higher-order unification to construct meaning representations.
    It also reviews the CCG grammar formalism and probabilistic extensions to it, including existing parsing and parameter estimation techniques.
    We assume that sentence meanings are represented as logical expressions, which we will construct from the meaning of individual words by using the operations defined in the lambda calculus.
    We use a version of the typed lambda calculus (cf.
    Carpenter (1997)), in which the basic types include e, for entities; t, for truth values; and i for numbers.
    There are also function types of the form (e, t) that are assigned to lambda expressions, such as Ax.state(x), which take entities and return truth values.
    We represent the meaning of words and phrases using lambda-calculus expressions that c