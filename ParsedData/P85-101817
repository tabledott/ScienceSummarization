 we are guaranteed to have only a finite number of equivalence classes.
    Actually, in the sequel we will use a particularly simple subclass of restrictors that are generable from sets of paths.
    Given a set of paths s, we can define (I) such that p43.1 if and only if p is a prefix of some p' E s. Such restrictors can be understood as &amp;quot;throwing away' all values not lying on one of the given paths.
    This subclass of restrictors is sufficient for most applications.
    However, the algorithms that we will present apply to the general class as well.
    Using our previous example, consider a restrictor 00 generated from the set of paths ((a b), (d e 1), (d ij f)}.
    That is, p4'01 for all p in the listed paths and all their prefixes.
    Then given the previous dag Do, D0f40 is Restriction has thrown away all the information except the direct values of (a b), (d e f), and (d if P. (Note however that because the values for paths such as (d e f (j) were thrown away, (Do(t(too)(((l e f)) is a var