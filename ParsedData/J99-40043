 of rules, each of the form A &#8212;&gt; a for A c N and a E (N u E)*.
    We will use the symbol = for immediate derivation and for its reflexive, transitive closure.
    We will illustrate the similarity of parsers for computing different values using the CKY algorithm as an example.
    We can write this algorithm in its iterative form as shown in Figure 1.
    Here, we explicitly construct a Boolean chart, chart[1..n,L.INI, 1..n + 1].
    Element char*, A, j] contains TRUE if and only if A we .
    .
    . w1_1.
    The algorithm consists of a first set of loops to handle the singleton productions, a second set of loops to handle the binary productions, and a return of the start symbol's chart entry.
    Next, we consider probabilistic grammars, in which we associate a probability with every rule, P(A &#8212;&gt; a).
    These probabilities can be used to associate a probability for 1 := 2 to n /* length, shortest to longest */ for s 1 to n&#8212; / +1 /* start position */ CKY inside algorithm. with a pa