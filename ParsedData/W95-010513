i and j = lion, with i &lt;j v[i, j) = sim(w[i], w[j]) c[i, j] = the most informative subsumer for w[i] and w[j] fork = 1 to num_senses(w[i]) if c[i, j] is an ancestor of sense[i, increment support[i, k] by v[i, j] fork' = 1 to num_senses(wW) if c[i, j] is an ancestor of sense[i, k'] increment support[j, k'] by v Ei, increment normalization[i] by v[i, j] increment normalization[j] by vii, j] This algorithm considers the words in W pairwise, avoiding the tractability problems in considering all possible combinations of senses for the group (0 (ma) if each word had m senses).
    For each pair considered, the most informative subsumer is identified, and this pair is only considered as supporting evidence for those senses that are descendants of that concept.
    Notice that by equation (1), support [i, k] is a sum of log probabilities, and therefore preferring senses with high support is equivalent to optimizing a product of probabilities.
    Thus considering words pairwise in the algorithm reflects a probabil