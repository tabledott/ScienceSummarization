izable split (b; c), which is a contradiction.
    A similar contradiction will arise if b and can make an inverted concatenation.
    Therefore, the algorithm will scan through the whole c as if from the empty stack.
    By the induction hypothesis again, it will reduce c into s[1] on the stack and recover its binarization tree bi(c).
    Since b and c are combinable, the algorithm reduces s[0] and s[1] in the last step, forming the binari zation tree for a, which is either [bi(b), bi(c)] or (bi(b), bi(c)). based on the property of permutations, it c2) is a valid straight concatec2) is a binarizable split to the are exactly n shifts and at most reductions, and n&#8722;1 O(1) time.
    The running time of Algorithm 1 is linear in n, the length of the input sequence.
    This is because there each shift or reduction takes Without loss of generality, we have discussed how to binarize synchronous productions involving only nonterminals through binarizing the corresponding skeleton permutations.
    We still need