s are incremented.
    The entire FastTBL algorithm is presented in Figure 1.
    Note that, when the bad counts are computed, only rules that already have positive good counts are selected for evaluation.
    This prevents the generation of useless rules and saves computational time.
    The number of examined rules is kept close to the minimum.
    Because of the way the rules are generated, most of them need to modify either one of their counts.
    Some additional space (besides the one needed to represent the rules) is necessary for representing the rules in a predicate hash in order to For all samples s that satisfy C [s] =&#65533; T [s], generate all rules r that correct the classification of s; increase good (r).
    For all samples s that satisfy C [s] = T [s] generate all predicates p s.t. p (s) = true; for each rule r s.t. pr = p and tr =&#65533; C [s] increase bad (r).
    1: Find the rule b = argmaxrER f (r). have a straightforward access to all rules that have a given predicate; this amount is c