 increase the overall score and do not violate the tree constraint.
    We can easily motivate this approximation by observing that even in non-projective languages like Czech and Danish, most trees are primarily projective with just a few non-projective edges (Nivre and Nilsson, 2005).
    Thus, by starting with the highest scoring projective tree, we are typically only a small number of transformations away from the highest scoring non-projective tree.
    The algorithm is shown in Figure 4.
    The expression y[i &#8594; j] denotes the dependency graph identical to y except that xi&#8217;s parent is xi instead shows how h1 creates a dependency to h3 with the second-order knowledge that the last dependent of h1 was h2.
    This is done through the creation of a sibling item in part (B).
    In the first-order model, the dependency to h3 is created after the algorithm has forgotten that h2 was the last dependent. of what it was in y.
    The test tree(y) is true iff the dependency graph y satisfies the tree 