 also generated by [AAA]; and similarly with (A (AA)) and ((AA)A), which can also be generated by (AAA).
    Thus the parse shown in (c) is preferable to either (a) or (b) since it does not make an unjustifiable commitment either way.
    Productions in the form of (c), however, are not permitted by the normal form we use, in which each bracket can only hold two constituents.
    Parsing must overcommit, since the algorithm is always forced to choose between (A(BC)) and ((AB)C) structures even when no choice is clearly better.
    We could relax the normal form constraint, but longer productions clutter the grammar unnecessarily and, in the case of generic bracketing grammars, reduce parsing efficiency considerably.
    Instead, we employ a more complicated but better-constrained grammar as shown in Figure 10, designed to produce only canonical tail-recursive parses.
    We differentiate type A and B constituents, representing subtrees whose roots have straight and inverted orientation, respectively.
    Unde